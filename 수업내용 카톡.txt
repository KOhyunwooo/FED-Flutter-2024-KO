[박석호강사] [오전 9:48] [ 오늘의 일정 : 7월30일(화) ]
------------------------------
1. 플러터 :플러터 PJ 구성하기(2,3) + 기본문법
2. 쉐도잉PJ 팔로우업 :
  (1) DC PJ - 서버배포
  -> 버셀(Vercel) 클라우드 서버(무료)
  (2) Pilot PJ - 최종 모듈 구성 마무리
3. 개인 PJ 구현 & 리뷰
[박석호강사] [오전 9:49] https://github.com/tombap8/FED-Flutter-2024-TOM
[박석호강사] [오전 9:49] 플러터 탐쌤 깃허브
[박석호강사] [오전 9:51] [ 리뷰예약 ]
1. 이은경
2. 김지현
// 다트 클래스 믹스인(다중상속) ////
/**************************************************** 
 * [다트 Mixin 이란?]
 * 다중 상속이 필요할 때 mixin을 사용함
 * mixin은 다른 코드에 더해질 목적으로 만들어진 클래스임
 * with 키워드는 클래스에 mixin 클래스를 사용할때 씀
 * 
 * 형식 : 
 * mixin 클래스명{}
 * 또는
 * mixin class 클래스명{}
 * -> class 키워드를 안쓰면 믹스인 전용클래스
 * -> class 키워드를 쓰면 개별 인스턴스 사용가능함!
 * -> 믹스인 전용클래스는 내부 생성자가 없다!
 * 그래서 인스턴스 생성이 안되는 것임!
 * 
 * [ 믹스인 사용클래스 형식 ]
 * class 클래스명 with 믹스인클래스,믹스인클래스,...{}
****************************************************/
// 믹스인 클래스 : 엔진파트
mixin Engine{
  // 엔진마력수
  int power = 5000;
}

// 믹스인 클래스 : 바퀴파트
mixin Wheel {
  // 바퀴정보
  String wheelInfo = "광폭4륜구동바퀴";
}
// 믹스인 클래스 : 라이트파트
mixin class Light { 
  // -> class 키워드사용으로 인스턴스가능!
  // 광도
  double luminosity = 3000.0;
}

/// 믹스인 없으면 어떻게 하지? -> 원래는 컴포지션 방법사용!

// 한국 엔진을 현대차에서 사용하게 함(상속방법아님!)

class K_Engine {
  // 출력
  int power = 8000;
  // 주행거리
  double distance = 500.0;
}

//  현대차 클래스
class HyunDai{
  // 컴포지션 방법 : 
  // 1. 내부에 외부 클래스 변수형선언함!
  K_Engine k_engine;
  // 2. 생성자에 초기화등록함!
  HyunDai(this.k_engine);
}



// 전기자동차 회사인 테슬라의 부품을 조달하도록 믹스인한다!
class Tesla with Engine, Wheel, Light {
  // 회사명
  final String compName;
  // 자동차 모델명
  final String model;
  // 가격
  final double price;
  // 주행거리
  double distance = 480.0;

  // 생성자 - 입력받을 속성값 셋팅!
  Tesla(this.compName,this.model,this.price);
} /////////// Tesla 클래스 ////////////


app_02_recipe


 /*
            [ Padding 위젯 ]
              padding: EdgeInsets.all(4방향전체),
              padding: EdgeInsets.only(left/top/right/bottom특정방향만),
              padding: EdgeInsets.symmetric(수직/수평중),
           */






           <section id="c2" className="cont">
        <Parallax
          className="c2"
          // 패럴랙스할 배경이미지 설정속성 bgImage
          bgImage={process.env.PUBLIC_URL+"/images/sub/" + 
          props.cat + "/02.special.png"}
          // 패럴랙스 이동정도 조정속성 strength
          // 수치범위 :  -500 ~ 1000 -> 높은 숫자는 반대방향
          strength={200}
        >
          <h2 className="c2tit sc-ani">2024 {gnbData[props.cat][1]}</h2>
        </Parallax>
      </section>


      // 리액트용 패럴랙스 - 설치 : npm i react-parallax
import { Parallax } from "react-parallax";



<section className="page">
        <FashionIntro catName="women" subCat="etc" opt={true} />
      </section>


       || (catName == "sub" && seq == 0) 


       (catName == "style" || (catName == "sub" && seq == 1))






       [ 오늘의 일정 : 7월31일(수) ]
------------------------------
1. 플러터 :플러터 PJ 구성하기
2. 나머지 업데이트
3. 수료식 : 오후 3:30 ~

/****************************************** 
 [다트 추상클래스]
 -> 형식을 강제할때 사용하는 클래스 생성방법
 -> 일반 상속과 달리 추상클래스는 모든 속성과
 메서드를 다 구현해야함!
 * 사용법:
 * abstract 키워드로 클래스를 선언한다->추상클래스
 * abstract는 추상화한...라는 뜻
 * 
  abstract class 추상클래스명{
    구현부
  }
 
 * 추상클래스를 상속 받는 것처럼 연결하는 방법은
 * implements 키워드로 연결한다!
 * implement는 시행하다...라는 뜻!
 * -> 추상클래스에 정의된 모든 속성과 메서드를 구현해야함!
 
 class 클래스명 implements 추상클래스명 {
    구현부
 }
******************************************/


// 추상클래스 연습 : 사람클래스를 추상클래스로 만들기
// -> 특정인물 클래스에서 사람클래스를 받아서 구현함!

abstract class Saram{
  // 생성자
  Saram(this.name);

  // 속성과 메서드 설계하기
  // ->>> 추상클래스 메서드는 
  // 구체적으로 구현하지 않는다! -> 해당클래스에서 구현
  // -> 그러나 대체적인 틀을 잡을 수 있음

  // 1. 이름속성
  final String name;
  // 2. 성별메서드
  String gender();
  // 3. 나이메서드
  String age();
  // 4. 먹다메서드 : 내용틀잡기
  String eat() => '$name씨는 지금 아무것도 안먹는다!';
  // 람다식 앞에 함수일 경우 Function키워드가 없다!

  // 5. 말하다메서드 : 내용틀잡기
  String say() => '$name씨는 지금 아무말도 안한다!';
} 




// 추상클래스를 상속(implements)받아 사용하기!
// -> 오버라이드 필수!(재정의를 반드시 해야함!)
// 도경수 배우의 클래스
class KyungSu implements Saram {
  @override
  late String _name; // 셋팅변수
  String get name => _name;
  set name(String name) => _name = name;

  // String get name => '도경수';
  // get 키워드는 겟터를 사용하는 변수를 선언함

  @override
  String gender() => '$name씨는 남자다!';

  @override
  String age() => '$name씨의 나이는 30살이다!';

  @override
  String eat(){return '$name씨는 피자를 먹는다!';}
  // String eat() => '$name씨는 피자를 먹는다!';

  @override
  String say() => '$name씨는 무엇인가 말하고 있다!';

} //////////// KyungSu 클래스 /////////////



/************************************************* 
 * [ 다트의 오버라이드(override) ]
 * - 기존의 정의된 속성과 메서드를 재정의 하는 것이다!
 * (그래서 위에 올라탄다는 단어를 쓰는 것임!)
 * -> 오버라이드 할때 어노테이션(주석)을 써준다!
 * @override : 오버라이드 표시역할 및 처리도움!
 * 
 * 참고: 다트에는 오버로드(overload)가 없다!
 * - 오버로드는 같은 이름의 메서드의 파라미터만 그 개수가
 * 다르게 여러게 만들수 있는 것으로 말함!

*************************************************/

/*************************************** 
[ 다트의 겟터 / 셋터 ]
변수값 읽기와 할당을 하도록 캡슐화를 하여
값 셋팅시 정보를 은닉하여 변수를 관리하는 방법

((방법:))
late 변수형 셋팅변수명;
변수형 get 변수명 => 셋팅변수명;
set 변수명(변수형 변수명) -> 셋팅변수명 = 변수명

((겟터/셋터 변수명))
일반적으로 변수명과 셋팅변수명은 같은이름이며 
셋팅변수명 앞에 언더바(_)를 붙여구분함
예) 변수명-> name, 셋팅변수명->_name

((late 키워드))
선언한 변수가 바로 할당되지 못할 경우
late 키워드를 앞에 사용하여 사용직전에
할당될 것임일 알려주면 에러를 막을 수 있다!

((겟터/셋터 값할당))
-> 외부에서 인스턴스 생성후 셋터를 통해 
값을 셋팅할 경우 변수명에 할당하면 된다!
클래스.변수명 = 값

 ***************************************/



 /// 남지현 배우 클래스 : Saram 클래스  일반 상속하기
 /// 일반상속은 부모클래스의 모든 내용을 재정의할 필요없음!
 /// -> 단, 구체적인 정의가 없는 메서드는 필수재정의!!!
 class JeeHyun extends Saram {
  // 생성자 : 받은 값을 부모클래스로 넘겨 먼저셋팅함!
   JeeHyun(String name) : super(name);

  @override
  String gender() => '$name씨는 여자다!';

  @override
  String age() => '$name씨는 28살이다!';

 } ////////// JeeHyun 클래스 ///////////



 // 일반적인 남자를 나타내는 클래스 /////////
 // 추상클래스임! -> 추상클래스를 일반상속한 추상클래스임!
 abstract class Namja extends Saram {
  // 생성자
  Namja(String name) : super(name);

  // 필수재정의는 없고 원하는 것을 재정의함!
  @override
  String gender() => '$name씨는 남자다!';

 } //////////// Namja 추상클래스 /////////////

 // 일반적인 여자를 나타내는 클래스 /////////
 // 추상클래스임! -> 추상클래스를 일반상속한 추상클래스임!
 abstract class Yeoja extends Saram {
  // 생성자
  Yeoja(String name) : super(name);

  // 필수재정의는 없고 원하는 것을 재정의함!
  @override
  String gender() => '$name씨는 여자다!';

 } //////////// Yeoja 추상클래스 /////////////




 /////// 박서준 배우의 클래스 /////////////
 /// 남자 추상클래스를 상속받는다!
 /// 추상클래스를 일반상속한 클래스는 추상클래스의 미정의 메서드를
 /// 필수정의 해야하는데 gender() 메서드는 상속받은
 /// 추상클래스인 Namja에서 이미 재정의 했으므로
 /// Saram 추상클래스에 남은 재정의 메서드 항목은 age만 남는다!
 class SeoJun extends Namja {
  SeoJun(String name) : super(name);

  // 필수재정의 항목 : age()
  String age() => '$name씨는 39살이다!';

  // 내가 추가로 하고 싶은 재정의하기
  String eat() => '$name씨는 햄버거를 먹는다!';

 } ///////// SeoJun 클래스 ///////////////



 /// 다중상속 믹스인 활용을 위한 클래스 만들기 /////
/// 취미에 대한 메서드를 구현한 Hobby 믹스인 만들기
/// class 키워드 없으면 단순 결합 클래스임(생성자없음!)
mixin Hobby {
  // 요리하다메서드
  String cook() => '씨는 지금 요리한다!';
  // 책읽다메서드
  String read() => '씨는 지금 책을 읽는다!';
} //////// Hobby 믹스인 클래스 ////////

// 가수 믹스인 만들기 /////////
// 믹스인에 on 키워드를 사용하면 특정클래스를 상속받은 경우
// 에만 다중상속을 하도록 제한할 수 있다!
// on Namja 라는 것은 남자클래스를 상속한 경우만 믹스인사용!
// -> 결과적으로 남자가수에만 사용가능!
mixin Singer on Namja {
  String sing() => '씨는 지금 노래한다!';
} //////// Singer 믹스인 클래스 /////////

///// 믹스인을 사용하는 이준호 배우겸 가수의 클래스 만들기///
class JunHo extends Namja with Hobby, Singer{
  // 생성자
  JunHo(String name) : super(name);

  // 필수재정의 메서드 : age()
  @override
  String age() => '$name씨는 33살이다!';

  // 선택적 재정의 : cook() -> Hobby 믹스인 클래스 메서드
  @override
  String cook() => '$name${super.cook()}';
  // Hobby 클래스의 cook() 메서드는 이름이 없으므로
  // 이름을 넣고 출력하기 위해 이 메서드를 호출하려고 함
  // 이때 부모를 지칭하는 super 키워드를 쓰면 된다!
  // super.cook()

// 선택적 재정의 : sing() -> Singer 믹스인 클래스 메서드
  @override
  String sing() => '$name${super.sing()}';
  // 믹스인 Singer 도 부모이므로 super 키워드에 잡힌다!
  // 이름과 메시지를 합쳐서 리턴함!

} /////////////// JunHo 클래스 ////////////////////////////////////////////////////////////////////////




//// 테스트를 수행하는 함수 //////////////////////////////////////////////////////////////
void testClass(){
  // 추상클래스를 구현한 경수클래스 인스턴스생성
  KyungSu ks = KyungSu();
  ks.name = '도경수';
  print(ks.eat());
  print(ks.say());
  print(ks.gender());
  print('\n');
  // print(KyungSu().eat());
  // print(KyungSu().say());

  // 추상클래스를 일반 상속받은 
  // 지현클래스 인스턴스 생성
  JeeHyun jh = JeeHyun('남지현');
  print(jh.age());
  print(jh.gender());
  print(jh.eat()); 
  // 재정의 안한 메서드는 
  // Saram의 원본 메서드가 출력됨!
  print('\n');

  // 추상클래스의 추상클래스를 상속한 
  // 서준클래스 인스턴스 생성
  SeoJun sj = SeoJun('박서준');
  print(sj.age());
  print(sj.eat());
  print('\n');

  // 추상클래스와 여러 믹스인 클래스를 상속받은 준호클래스
  // 인스턴스 생성하기
  JunHo jho = JunHo('이준호');
  print(jho.gender());
  print(jho.age());
  print(jho.cook());
  print(jho.sing());

} ////// testClass /////////////////////////////////////////////////////////////////////////////



import 'package:flutter/material.dart';
// 레시피홈 클래스 페이지 불러오기
import 'package:app_02_recipe/pages/recipe_page.dart';

void main() {
  //  플러터의 출발 메서드!
  runApp(const MyApp());
}

// 초기호출 클래스는 비상태위젯을 상속받음!
class MyApp extends StatelessWidget {
  const MyApp({super.key});

  // 머티리얼앱 위젯을 사용하여 디자인한다!
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      // 머티리얼앱 시작!
      // 디버그모드 표시 숨기기
      debugShowCheckedModeBanner: false,
      // theme 테마 속성 - 앱전체에 적용하는 속성값들셋팅
      theme: ThemeData(
        // 전체 폰트적용하기 :
        // fontFamily속성은 하나의 폰트만 적용됨
        // fontFamilyFallback속성이 여러폰트 적용됨
        // fontFamilyFallback: [리스트형 폰트명데이터입력]
        fontFamilyFallback: ["PatuaOne","Diphylleia"],
      ),
      // 레시피 홈 클래스 상단에 import후 호출!
      home: RecipePage(),
    );
  }
}


// 황금 레시피 페이지홈 클래스 ///////////////////////////////////////////////////////////////////////

import 'package:flutter/material.dart';
// 쿠퍼티노 아이콘 사용위해 쿠퍼티노앱 추가
import 'package:flutter/cupertino.dart';

// 레시피 컴포넌트 불러오기 : 타이틀, 메뉴, 리스트아이템
import 'package:app_02_recipe/components/recipe_title.dart';
import 'package:app_02_recipe/components/recipe_menu.dart';
import 'package:app_02_recipe/components/recipe_list_item.dart';

class RecipePage extends StatelessWidget {
  // 생성자 메서드에서 key를 받아서 부모 속성을 셋팅함
  // key는 이미만들어진 부모위젯에서 받는 기본값
  // 이 값은 우리가 넘겨주지 않아도 셋팅은 되어야함!
  const RecipePage({Key? key}) : super(key: key);
  // Key? key -> Key클래스 형 변수 key가 null이어도
  // 그 값을 null처리 하지 않고 "null"문자열로 처리해줌!
  // -> 널 세이프티(null safety)라고 한다!(물음표사용!)

  // build 메서드를 재정의함!
  @override
  Widget build(BuildContext context) {
    // 가장 바깥쪽 레이아웃 Scaffold 위젯으로 시작!
    return Scaffold(
      // 1. 전체 배경색 설정하기
      backgroundColor: Colors.white,
      // 2. 앱바구현 메서드 호출하기
      appBar: _buildRecipeAppBar(),
      // 3. body 구현하기

      body: Padding(
        // 상하/좌우 대칭 여백패딩설정(symmetric:대칭적인)
        // symmetric(horizontal:숫자,vertical:숫자)
        padding: const EdgeInsets.only(left: 20, right: 20, bottom: 50),
        // const EdgeInsets.symmetric(horizontal: 20),
        // Column 위젯대신 ListView 위젯을
        // 사용해야 스크롤바 표시가 된다!
        child: ListView(
          children: [
            // 1.레시피 페이지 전체타이틀
            RecipeTitle(),
            // 2.레시피 페이지 메뉴
            RecipeMenu(),
            // 3.레시피 페이지 아이템
            RecipeListItem('coffee', '커피 레시피'),
            RecipeListItem('burger', '수제버거 레시피'),
            RecipeListItem('pizza', '피자 레시피'),
          ],
        ),
      ),
    );
  }
}

// 앱바 클래스 만들기 ////////
// 리턴형은 AppBar
// 앱바 메서드 이름은 주로 (언더바_)로 시작함
AppBar _buildRecipeAppBar() {
  return AppBar(
    // 앱바 배경색
    backgroundColor: const Color.fromARGB(255, 226, 226, 226),
    // elevation속성 :앱바 그림자효과 조정속성
    elevation: 1.0,
    // actions 속성 : 앱바 컨텐츠 파트[리스트형]
    actions: [
      // 아이콘 위젯 - Icon
      Icon(
        // 아이콘 옵션중 쿠퍼티노가 유명함
        // 주의: 쿠퍼티노앱 상단 import 추가!
        CupertinoIcons.search,
        color: Colors.blueGrey,
      ),
      SizedBox(
        width: 15,
      ), //사이간격박스
      Icon(
        CupertinoIcons.heart,
        color: Colors.redAccent,
      ),
      SizedBox(
        width: 15,
      ), //사이간격박스
    ],
  );
} //// _buildRecipeAppBar 메서드 //////

// 앱바는 앱 최상단 구역을 차지하며
// 구성요소로는 
// 1. leading - 앱바 상단왼쪽끝파트
// 2. title - 앱바 타이틀파트
// 3. actions - 앱바 컨텐츠파트
// 4. flexibleSpace - 앱바 하단파트 위 공간
// -> SafeArea위젯에서 이 공백을 자동조정함!
// 5. bottom - 앱바 하단파트






// 황금 레시피 리스트 아이템 클래스 ////////////////////////////////////////////////////////////////////////////////

import 'package:flutter/material.dart';

// 두개의 값을 전달 받아 처리한다!
// 1. 이미지이름 / 2. 타이틀
class RecipeListItem extends StatelessWidget {
  // 클래스 맴버속성 만들기
  final String imageName;
  final String title;
  // 클래스 호출할때 생성시 이 값을 전달해줌!

  // 맴버 속성을 셋팅하도록 생성자메서드를 변경한다!
  // key값 전달은 기본이므로 포함하여 변경한다!
  const RecipeListItem(this.imageName, this.title, {Key? key})
      : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.only(top:20),
      child: Column(
        children: [
          // 1.이미지 : 맴버변수 imageName사용
          // 비율설정위젯 - AspectRatio
          AspectRatio(
            aspectRatio: 2 / 1,
            // 사각 잘라내기 위젯
            child: ClipRRect(
              borderRadius: BorderRadius.circular(20),
              child: Image.asset(
                "assets/images/$imageName.jpeg",
                // 이미지 확장 채우기(중요!!!)
                fit: BoxFit.cover,
              ),
            ),
          ),
      
          SizedBox(
            height: 10,
          ), // 사이간격
      
          // 2.텍스트 : 맴버변수 title사용
          Text(
            title,
            style: TextStyle(
              fontSize: 20,
              fontWeight: FontWeight.bold,
            ),
          ),
      
          // 3. 레시피 소개글
          Text(
            "당신은 당신이 직접만든 $title를 가지고 계신가요? 만약없다면 여기 쉽고 훌륭한 $title를 보고 따라해 보세요! 틀림없이 좋은 결과를 만나실 겁니다!",
            style: TextStyle(
              color: Colors.black,
              fontSize: 14,
              fontWeight: FontWeight.bold,
            ),
          )
        ],
      ),
    );
  }
}





prefer_const_constructors: false
    prefer_const_literals_to_create_immutables: false
    prefer_const_constructors_in_immutables: false





    // 황금 레시피 페이지 메뉴 클래스 /////////////////////////////////////////////////////////////////

import 'package:flutter/material.dart';

class RecipeMenu extends StatelessWidget {
  const RecipeMenu({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 10, horizontal: 5),
      child: Row(
        children: [
          // 박스형 메뉴 생성 메서드호출
          _buildMenuItem(
            Icons.food_bank,
            'All',
          ),
          Spacer(),
          _buildMenuItem(
            Icons.emoji_food_beverage,
            'Coffee',
          ),
          Spacer(),
          _buildMenuItem(
            Icons.fastfood,
            'Burger',
          ),
          Spacer(),
          _buildMenuItem(
            Icons.local_pizza,
            'Pizza',
          ),
        ],
      ),
    );
  }
}

// 메뉴구성 위젯을 리턴하는 메서드
// 하위 메서드 이므로 언더바로 시작하는 이름사용!
// 각 메뉴별 변경요소 전달값으로 받아서 처리!
// 전달변수: 1. 아이콘 / 2. 텍스트
Widget _buildMenuItem(IconData mIcon, String text) {
  // 박스를 구성하는 Container 위젯!
  // 박스는 크기를 가진다! 따라서 width,height 속성이필수!
  return Container(
    // 1. 가로, 세로 크기지정
    width: 70,
    height: 80,

    // 2. 박스 세부옵션 설정 - decoration
    decoration: BoxDecoration(
        // 보더속성
        border: Border.all(color: Colors.black12),
        // 보더 라운드 속성
        borderRadius: BorderRadius.circular(10),
        // 그라데이션 속성
        gradient: LinearGradient(
          // 그라데이션 색상지정
          colors: [
            Color.fromARGB(255, 238, 206, 105),
            Color.fromARGB(255, 193, 133, 19),
            Color.fromARGB(255, 253, 249, 201),
            Color.fromARGB(255, 238, 206, 105),
            Color.fromARGB(255, 255, 249, 184),
          ],

          // 각 색상이 어디까지 변화할지 지정(0.0~1.0)
          stops: [
            0.1,
            0.2,
            0.4,
            0.7,
            0.8,
          ],
          // 그라데이션 시작위치/끝위치 지정
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
        )),

    // 3. 박스 하위요소 속성 : 단일요소 -> child
    child: Column(
        // 박스 세로정렬 중앙
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          // 3-1. 아이콘
          Icon(
            mIcon,
            color: Colors.redAccent,
            size: 30,
          ),
          // 내가 원하는 크기만큼 사이간격주는
          // 방법은 SizedBox(width/height)
          SizedBox(
            height: 3,
          ),
          // 3-2. 글자
          Text(
            text,
            style: TextStyle(
              color: Colors.red.shade900,
              fontWeight: FontWeight.bold,
              fontSize: 20,
            ),
          )
        ]),
  );
}






// 황금 레시피 타이틀 클래스 ////////////////////////////////////////////////////////////////

import 'package:flutter/material.dart';

class RecipeTitle extends StatelessWidget {
  const RecipeTitle({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Padding(
      // 상단여백 : only(top/left/right/bottom)
      padding: const EdgeInsets.only(top: 20),
      child: Center(
        child: Text(
          "황금 레시피",
          style: TextStyle(
            fontSize: 30,
            fontWeight: FontWeight.bold,
          ),
        ),
      ),
    );
  }
}





   - family: Diphylleia
      fonts:
        - asset: assets/fonts/Diphylleia-Regular.ttf
    - family: PatuaOne
      fonts:
        - asset: assets/fonts/PatuaOne-Regular.ttf